---
layout: post
title: Stream详解
tags:
- java
- jdk8
---

## BaseStream
`public interface BaseStream<T, S extends BaseStream<T, S>> extends AutoCloseable`

1. S onClose(Runnable)
接受一个Runnable接口,返回一个Stream类型,由于实现了AutoClosable接口,所以可以用try-with-resource的方法自动关闭.该函数也在close()调用时被执行,同时也可以串联添加.
注意要点:
- 多个Runnable按照添加顺序执行,如果前面的抛出了异常不会影响后面的执行
- 只有第一个异常会返回到close函数的调用者,其余的都会被压缩在这个异常中
- 如果有和第一个异常相同的异常(需要对象相同),则只返回一次

## Stream
将原有的外部迭代耦合成了内部迭代
1. collect的三个参数
<R> R collect(Supplier<R> supplier,
                  BiConsumer<R, ? super T> accumulator,
                  BiConsumer<R, R> combiner);
其中第一个supplier提供一个返回值类型的对象,accumulator使用supplier提供的对象apply stream中的每个元素,如果使用并行流则可能出现多个返回值对象,所以需要combiner合成一个返回值对象,所以在非并行情况下不会调用,
或者直接接受一个Collector对象

2. Stream.iterate(final T seed, final UnaryOperator<T> f)
根据这个seed,每次调用f(seed)作为下一个值,生成一个无限的流,必须用limit限制.同时如果使用了distinct并且放在limit之前程序能执行但不会停止.

3. Collectors.groupBy()
函数有3个重载版本,接受一个分类器,接受一个流里的元素,返回一个key,通过组合相同的key构成一个Map<T, List<V>>的map.
同时接受两个参数的版本可以传入对组操作的函数,例如Collectors.counting就会返回Map<T, Long>其中value为每组元素的个数,其他Collectors自行了解.

4. Collectors.partitioningBy()
是groupBy的一个特殊情况,只能返回相对立的两个分区.例如通过分数>90和<=90创造两个分区,其余和groupBy类似

5. 流的短路操作
流的操作不是通过对所有流容器对象进行A中间操作,再对所有对象进行B中间操作.
而是直接以容器中每个对象为单位,逐一通过所有的中间操作
```java
List<String> list = new LinkedList<>(Arrays.asList("asdf", "xzcvf", "fewfe"));
        list.stream()
                .filter(str -> {
                    System.out.println(str);
                    return str.length() == 5;
                })
                .findFirst()
                .toString();
                
//输出
asdf
xzcvf
```
因为findFirst是一个短路操作,所以在“xzcvf”通过整个流操作以后,就截断了后续的对象处理.
Stream API中有6个短路操作,基本都是find,match,limit有关函数

*注意:流是无法重新使用的(每次中间操作是返回了一个新的Stream对象,所以多次中间操作是可以的)*

## ParallerStream
简单测试,以一个500个字符串构成的流为例,应用MyCollector<T, Set<T>, Map<T,T>>, 作用为把每个字符串变成{A:A, B:B,...}的map

默认添加Characteristics.UNORDERED特性 (关于Collector特性的说明见《~Collector详解》)

显示信息有:
count 数组长度
supplierCount   supplier被调用次数
accumulatorCount   accumulator被调用次数
combinerCount   combiner被调用次数
threadCount   参与工作线程个数

1. 使用串行流
> count:500
> supplierCount:1
> accumulatorCount:500
> combinerCount:0
> threadCount:1  
> 
很明显,不做解释

2. 使用并行流
> count:500
> supplierCount:32
> accumulatorCount:500
> combinerCount:31
> threadCount = ? < CPU核心数(有超核心的存在,所以4核可能达到8核)
3. 我电脑:7
> 
这里要注意的是combinerCount = supplierCount - 1

3. 使用并行流 + Characteristics.CONCURRENT特性
> count:500
> supplierCount:1
> accumulatorCount:500
> combinerCount:0
> threadCount:8
> 
由于加入了CONCURRENT特性,所以告诉JVM代码支持多线程同时对中间结果容器同时操作,以至于supplier只调用一次,即八个线程同时操作同一个容器

4. 使用并行流 + Characteristics.CONCURRENT特性 + 「破坏CONCURRENT特性的操作」
```java
public BiConsumer<Set<T>, T> accumulator() {
        return(set, e) -> {
            System.out.println(set);
            set.add(e);
        };
    }
    
// 抛出异常
java.util.ConcurrentModificationException: java.util.ConcurrentModificationException
```
这是因为在HashSet中修改了值,同时println又会遍历set,如果正好在遍历中修改了值,会触发HashMap(HashSet是通过HashMap实现的)中的检查
```
if (modCount != expectedModCount)
                throw new ConcurrentModificationException();
```
所以在添加CONCURRENT特性时,必须保证类似的情况

共有特性说明:
1. accumulatorCount = count
2. threadCount = ? < CPU核心数(有超核心的存在,所以4核可能达到8核)
3. 我电脑supplierCount <= 32,这个没有仔细研究


### sequential() parallel()
除了调用stream()或者parallelStream()生成串行或者并行流,也可以调用流的sequential() parallel()的方法使流变成串行或并行的,由于sequential() parallel()返回的是流,所以理论可以.sequential().parallel().parallel()....

其实这四种方法都只是改变了Pipeline中的一个parallel的标志位,所以一个流是串行还是并行就看最后一个修改标志位的函数是什么就行了