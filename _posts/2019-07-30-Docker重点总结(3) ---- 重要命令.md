---
layout: post
title: Docker重点总结(3) ---- 重要命令
tags:
- linux
- docker
---

# pull
Docker Hub 上有大量的高质量的镜像可以用，这里我们就说一下怎么获取这些镜像。

```bash
docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]
```

- Docker 镜像仓库地址：地址的格式一般是 <域名/IP>[:端口号]。默认地址是 Docker Hub。
- 仓库名：如之前所说，这里的仓库名是两段式名称，即 <用户名>/<软件名>。对于 Docker Hub，如果不给出用户名，则默认为 library，也就是官方镜像。

例子:
```bash
$ docker pull ubuntu:18.04
18.04: Pulling from library/ubuntu
bf5d46315322: Pull complete
9f13e0ac480c: Pull complete
e8988b5b3097: Pull complete
40af181810e7: Pull complete
e6f7c7e5c03e: Pull complete
Digest: sha256:147913621d9cdea08853f6ba9116c2e27a3ceffecf3b492983ae97c3d643fbbe
Status: Downloaded newer image for ubuntu:18.04
```

上面的命令中没有给出 Docker 镜像仓库地址，因此将会从 Docker Hub 获取镜像。而镜像名称是 ubuntu:18.04，因此将会获取官方镜像 library/ubuntu 仓库中标签为 18.04 的镜像。

从下载过程中可以看到我们之前提及的分层存储的概念，**镜像是由多层存储所构成**。**下载也是一层层的去下载**，并非单一文件。下载过程中给出了每一层的 ID 的前 12 位。并且下载结束后，给出该镜像**完整的 sha256 的摘要**，以**确保下载一致性**。

在使用上面命令的时候，你可能会发现，你所看到的层 ID 以及 sha256 的摘要和这里的不一样。这是因为官方镜像是一直在维护的，有任何新的 bug，或者版本更新，**都会进行修复再以原来的标签发布**(这不和前面的下载一致性冲突了吗?)，这样可以确保任何使用这个标签的用户可以获得更安全、更稳定的镜像。

# run 以及 操作容器
```bash
docker run -it --rm ubuntu:18.04 bash
```
- -it：这是两个参数，一个是 **-i**：交互式操作，一个是 **-t**终端。我们这里打算进入 bash 执行一些命令并查看返回结果，因此我们需要交互式终端。
- --rm：这个参数是说容器**退出后随之将其删除**。默认情况下，为了排障需求，退出的容器并不会立即删除，除非手动 docker rm。我们这里只是随便执行个命令，看看结果，不需要排障和保留结果，因此使用 --rm 可以避免浪费空间。
- ubuntu:18.04：这是指用 ubuntu:18.04 镜像为基础来启动容器。
- bash：放在镜像名后的是 命令，这里我们希望有个交互式 Shell，因此用的是 bash。

### 执行流程
当利用 `docker run` 来创建容器时，Docker 在后台运行的标准操作包括:
- 检查本地是否存在指定的镜像，不存在就从公有仓库下载
- 利用镜像创建并启动一个容器
- 分配一个文件系统，并在只读的镜像层外面挂载一层可读写层
- 从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去
- 从地址池配置一个 ip 地址给容器
- 执行用户指定的应用程序
- 执行完毕后容器被终止

### start stop restart
run是通过镜像创建并执行一个容器，基于创建的容器还可以使用这三个操作
其中终止的容器只能通过`docker ps -a`查看，其状态为Exited
#### 注意
很多人以为运行了一个容器，其内容执行完毕容器就会被删除,例如`docker run alpine "/bin/sh" -c "mkdir gaga"`，以为只是简单的运行了一条语句容器就消亡了，然而只是容器的状态变为了Exited(code)即停止态，可以通过`docker ps -a`查看，再次exec回去你能发现gaga文件夹已被创建
所以只有真正的使用了rm才能真正的删除，或者使用`docker container prune`删除所有exited的容器

### attach exec
通过attach， exec都可以进入正在执行的容器
但是使用attach是接入docker运行容器的同一个tty，所以一旦exit推出后容器也随之终止消失
如果使用exec则可以新创建一个tty并接入容器

### export import load
容器可以导出成文件，也可以从文件导入,相当于容器快照
```bash
docker export 7691a814370e > ubuntu.tar
cat ubuntu.tar | docker import - test/ubuntu:v1.0
docker import http://example.com/exampleimage.tgz example/imagerepo
```

用户既可以使用 `docker load` 来导入镜像存储文件到本地镜像库，也可以使用 `docker import` 来导入一个容器快照到本地镜像库。这两者的区别在于**容器快照文件**将**丢弃所有的历史记录和元数据信息**（即仅保存容器当时的快照状态），而**镜像存储文件将保存完整记录，体积也要大**。此外，从容器快照文件导入时可以重新指定标签等元数据信息。


# image
`docker images` 或者 `docker image list` 都是查看现有image的命令
格式如下:
|REPOSITORY|TAG|IMAGE ID|CREATED|SIZE|
|-|-|-|-|-|
|redis|latest|5f515359c7f8|5 days ago|183 MB|
|ubuntu|18.04|f753707788c5|4 weeks ago|127 MB|
|ubuntu|latest|f753707788c5|4 weeks ago|127 MB|
|<none>|<none>|00285df0df87|5 days ago|342 MB|

列表包含了 仓库名、标签、镜像 ID、创建时间 以及 所占用的空间
其中**镜像ID**是镜像的唯一ID, 所以ubuntu:18.04 和 ubuntu:latest 是同一个镜像

### 镜像体积
这里标识的所占用空间和在 Docker Hub 上看到的镜像大小不同。
比如，ubuntu:18.04 镜像大小，在这里是 127 MB，但是在 Docker Hub 显示的却是 50 MB。这是因为 Docker Hub 中显示的体积是**压缩后的体积**。在镜像下载和上传过程中镜像是保持着压缩状态的，因此 Docker Hub 所显示的大小是**网络传输中更关心的流量大小**。而 `docker image ls` 显示的是镜像下载到本地后，展开的大小，准确说，是展开后的各层所占空间的总和，因为镜像到本地后，查看空间的时候，**更关心的是本地磁盘空间占用的大小。**

另外一个需要注意的问题是，`docker image ls` 列表中的**镜像体积总和并非是所有镜像实际硬盘消耗**。由于 Docker 镜像是**多层存储结构**，并且可以**继承、复用**，因此**不同镜像可能会因为使用相同的基础镜像，从而拥有共同的层**。由于 Docker 使用 `Union FS`，**相同的层只需要保存一份**即可，因此实际镜像硬盘占用空间很可能要比这个列表镜像大小的总和要小的多。

可以通过`docker system df`查看真实的磁盘用量

### 虚悬镜像(dangling image)
这个也是很多人摸不着头脑的一种镜像类型

上面的镜像列表中，还可以看到一个特殊的镜像，这个镜像既没有仓库名，也没有标签，均为 <none>

这个镜像**原本是有镜像名和标签**的，原来为 mongo:3.2，随着官方镜像维护，发布了新版本后，重新 `docker pull mongo:3.2` 时，mongo:3.2 这个镜像名被**转移**到了新下载的镜像身上，而旧的镜像上的这个名称则被**取消**，从而成为了 <none>。除了 `docker pull` 可能导致这种情况，`docker build` 也同样可以导致这种现象。由于新旧镜像同名，旧镜像名称被取消，从而出现仓库名、标签均为 <none> 的镜像。这类无标签镜像也被称为 虚悬镜像(dangling image)

可以用下面的命令专门显示这类镜像
`docker image ls -f dangling=true`

一般来说，虚悬镜像已经失去了存在的价值，是可以随意删除的，可以用下面的命令删除。
`docker image prune`

### 中间层镜像
为了加速镜像构建、重复利用资源，Docker 会利用 **中间层镜像**。所以在使用一段时间后，可能会看到一些依赖的中间层镜像。默认的 `docker image ls` 列表中**只会显示顶层镜像**，如果希望显示包括中间层镜像在内的所有镜像的话，需要加 -a 参数。
`docker image ls -a`
如果想看某一个镜像的每一层则使用
`docker image distory <image>`

这样会看到很多<none>的镜像，**与之前的虚悬镜像不同**，这些无标签的镜像很多都是中间层镜像，是其它镜像所依赖的镜像。这些无标签镜像**不应该删除**，否则会导致**上层镜像因为依赖丢失而出错**。实际上，这些镜像也没必要删除，因为之前说过，相同的层只会存一遍，而这些镜像是别的镜像的依赖，因此并不会因为它们被列出来而多存了一份，无论如何你也会需要它们。只要**删除那些依赖它们的镜像**后，这些依赖的中间层镜像也会被**级联删除**。

### 列出部分镜像
当镜像特别多的时候(尤其是开发机上一个项目多个不同的提交提交版本),单单使用`docker image list`很难找到某一项,所以在检索中提供了filter功能, 使用 -f 参数, 以及字段匹配

```shell
docker image list ubuntu  # 找到image带有ubuntu的image
docker image list -f since=mysql:5.7  # 找到mysql:5.7 pull日期后的所有image, 同理since -> before

# 如果image构建时定义了label, 也可以指定label
```

如果使用 -q 只会输出id

如果对默认输出模板不满意可以自定义模板, [go模板网站](https://gohugo.io/templates/go-templates/)
尝试一下: `docker image ls --format "{{.ID}}: {{.Repository}}"`

# rm
`docker image rm [选项] <镜像1> [<镜像2> ...]`
其中，<镜像> 可以是 **镜像短 ID**、**镜像长 ID**、**镜像名** 或者 **镜像摘要**。
短,长ID不作解释,镜像名是<仓库名>:<标签>, 镜像摘要则需要通过`docker image ls --digests`查看
甚至我们可以输入镜像短ID的前三位就可区别出一个镜像来删除

### Untagged 和 Deleted
```shell
$ docker image rm centos
Untagged: centos:latest
Untagged: centos@sha256:b2f9d1c0ff5f87a4743104d099a3d561002ac500db1b9bfa02a783a46e0d366c
Deleted: sha256:0584b3d2cf6d235ee310cf14b54667d889887b838d3f3d3033acd70fc3c48b8a
Deleted: sha256:97ca462ad9eeae25941546209454496e1d66749d53dfa2ee32bf1faabd239d38
```
如果观察上面这几个命令的运行输出信息的话，你会注意到删除行为分为两类，一类是 `Untagged`，另一类是 `Deleted`。我们之前介绍过，镜像的唯一标识是其 ID 和摘要，而一个镜像可以有多个标签。

因此当我们使用上面命令删除镜像的时候，**实际上是在要求删除某个标签的镜像**。所以首先需要做的是将满足我们要求的所有镜像标签都取消，这就是我们看到的 `Untagged` 的信息。因为一个镜像可以对应**多个标签**，因此当我们删除了所指定的标签后，可能还有别的标签指向了这个镜像，如果是这种情况，那么 `Delete` 行为就不会发生。所以并非所有的 `docker image rm` 都会产生删除镜像的行为，有可能仅仅是**取消了某个标签而已**。

当该镜像**所有的标签都被取消**了，该镜像很可能会失去了存在的意义，因此会触发**删除**行为。镜像是**多层存储结构**，因此在删除的时候也是从上层向基础层方向依次进行判断删除。镜像的多层结构让镜像复用变得非常容易，因此很有可能某个其它镜像正依赖于当前镜像的某一层。这种情况，依旧不会触发删除该层的行为。直到没有任何层依赖当前层时，才会真实的删除当前层。这就是为什么，有时候会奇怪，为什么明明没有别的标签指向这个镜像，但是它还是存在的原因，也是为什么有时候会发现所删除的层数和自己 `docker pull` 看到的层数不一样的原因。

除了镜像依赖以外，还需要注意的是**容器对镜像的依赖**。如果有用这个镜像启动的容器存在（**即使容器没有运行**），那么同样不可以删除这个镜像。之前讲过，容器是以镜像为基础，再加一层容器存储层，组成这样的多层存储结构去运行的。因此该镜像如果被这个容器所依赖的，那么删除必然会导致故障。如果这些容器是不需要的，应该先将它们删除，然后再来删除镜像。

> 简而言之: `docker image rm` -> 检查容器依赖 -> 从对应镜像上去除指定标签，如果镜像上无标签 ->
分层由上至下删除没有被依赖的层

### rm 与 docker image ls 配合使用
```shell
docker image rm $(docker image ls -q -f before=mongo:3.2)  # 等
```