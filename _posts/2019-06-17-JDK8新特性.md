---
layout: post
title: jdk8新特性
tags:
- java
- jdk8
---

## FunctionalInterface
1. 如果一个接口只有一个**抽象方法**，那么该接口就是函数式接口。
2. 如果我们在某个接口上声明了`FUnctionalInterface`注解，那么编译器就会按照函数式接口的定义来要求该接口。
3. 如果某个接口只要一个抽象方法，但我们并没有给该接口声明此注解，编译器依旧会认为该接口为函数式接口。
4. 如果接口中有复写Object的方法不算做抽象方法，因为所有类的父类都是Object，所以无法避免。

在JAVA中，Lambda表达式添加了缺失的函数式编程特性，但是Lambda表达式仍是**对象**，他们必须依附于一类特别的对象类型——函数式接口
函数式接口可以通过`Lambda表达式`, `方法引用`,`构造方法应用`来构造

## Function接口
//Represents a function that accepts one argument and produces a result.
@FunctionalInterface
public interface Function<T, R> {}

实例化Function接口需要重写apply方法
如何实例化Function接口:
1. 方法引用`Function<String, String> function=String::toUpperCase;`很明显toUpperCase是一个实例化方法,并且不接受参数,但Function的apply方法需要接受一个参数,但是toUpperCase是需要一个调用者String对象的,所以我们通过`类::实例方法`去声明Function接口,编译器会把调用者解释为apply接收的参数.
2. BiFunction(BidirectionFunction)接收两个参数返回一个值

## Lambda
匿名函数,传递行为,JAVA8之前函数参数只能传递值

## 方法引用
可以讲方法引用看作[函数指针], 是Lambda表达式的一种语法糖,
很容易想到,如果一个函数接受参数Consumer,但是传入的却是System.out::println是没问题的,所以其实不是直接调用System.out::println这个方法,而是通过这个「兼容的函数式接口」构成目标类型上下文,计算时，方法引用会创建函数式接口的一个实例。

所以方法引用仍是一个Lambda表达式,而不是方法**调用**.
1. 类名::静态方法名
2. 对象名::实例方法名
3. 类名::实例方法名(传入参数为调用者对象)
4. 类名::new(构造方法引用,其中参数如何对应由编译器自动识别)

## Stream
collector内容过多,见另一篇笔记《~Stream详解》

## Collector
collector内容过多,见另一篇笔记《~Collector详解》

## Optional
规避NPE NullPointerException 异常
推荐使用ifPresent(Consumer)函数式编程,而不是仍旧通过if先判断再写

## Comparator
这不是JDK8中新出来的类,但是由于JDK的默认方法的出现,Comparator出现了一些默认的特化方法

1. 默认带了comparingInt, comparingLong, comparingDouble,当然可以直接用非特化的版本,但是特化的优势在于**忽略了自动拆箱装箱**,效率提高, 所以能使用这三种类型的尽量用特化的方法.
2. thenComparing,链式比较

tip:
```java
List<String> words = Arrays.asList("fsdf", "cvxzcvd", "adsa", "wccd");
        words.sort(Comparator.comparingInt(item -> item.length()).reversed());
```
此时length是红色的,即无法通过编译
因为comparingInt返回的Comparator<T>没有指定T的类型,所以编译器自动推断为Object,导致无法使用.length()方法,所以必须显示指定类型,或者改用String::length.但是如果不使用reversed()或者thenComparing()方法,就不会报错.

可以直接调用words.sort(String.CASE_INSENSITIVE_ORDER), 这是String中实现的静态内部(比较器)类,实现了字符串的忽略大小写的自然顺序
